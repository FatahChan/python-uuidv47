import pytest

from python_uuidv47 import decode, encode, set_keys, uuid_parse


class TestCrossLanguageCompatibility:
    """
    Test compatibility with Node.js implementation using shared test vectors.

    These tests ensure that the Python implementation produces identical results
    to the Node.js version for the same inputs and keys.
    """

    def setup_method(self):
        """Set up test environment"""
        # Use consistent keys for cross-language testing
        set_keys(0x123456789ABCDEF0, 0xFEDCBA9876543210)

    @pytest.fixture
    def test_vectors(self):
        """
        Test vectors that should be shared between Python and Node.js implementations.

        These vectors include:
        - Original UUIDv7
        - Expected facade (encoded result)
        - Keys used for encoding

        In a real implementation, these would be loaded from a shared file
        or generated by a reference implementation.
        """
        return [
            {
                "keys": {"k0": 0x123456789ABCDEF0, "k1": 0xFEDCBA9876543210},
                "original": "550e8400-e29b-71d4-a716-446655440000",
                "facade": None,  # Will be computed and verified
                "description": "Basic UUIDv7 test case",
            },
            {
                "keys": {"k0": 0x0000000000000000, "k1": 0x0000000000000000},
                "original": "01234567-89ab-7def-8123-456789abcdef",
                "facade": None,
                "description": "Zero keys test case",
            },
            {
                "keys": {"k0": 0xFFFFFFFFFFFFFFFF, "k1": 0xFFFFFFFFFFFFFFFF},
                "original": "fedcba98-7654-7321-8098-765432109876",
                "facade": None,
                "description": "Maximum keys test case",
            },
            {
                "keys": {"k0": 0x1111111111111111, "k1": 0x2222222222222222},
                "original": "12345678-9abc-7def-8456-123456789abc",
                "facade": None,
                "description": "Pattern keys test case",
            },
            {
                "keys": {"k0": 0xAAAAAAAAAAAAAAAA, "k1": 0x5555555555555555},
                "original": "abcdef01-2345-7678-89ab-cdef01234567",
                "facade": None,
                "description": "Alternating pattern test case",
            },
        ]

    def test_encode_compatibility(self, test_vectors):
        """Test that encoding produces consistent results"""
        for vector in test_vectors:
            # Set the keys for this test vector
            set_keys(vector["keys"]["k0"], vector["keys"]["k1"])

            # Encode the original UUID
            facade = encode(vector["original"])

            # Store the result for future reference
            vector["facade"] = facade

            # Verify the facade is a valid UUID
            assert uuid_parse(facade) == 1, (
                f"Invalid facade for {vector['description']}"
            )
            assert len(facade) == 36, f"Wrong facade length for {vector['description']}"

            # Verify roundtrip works
            decoded = decode(facade)
            assert decoded == vector["original"], (
                f"Roundtrip failed for {vector['description']}"
            )

    def test_decode_compatibility(self, test_vectors):
        """Test that decoding produces consistent results"""
        # First generate facades
        self.test_encode_compatibility(test_vectors)

        for vector in test_vectors:
            # Set the keys for this test vector
            set_keys(vector["keys"]["k0"], vector["keys"]["k1"])

            # Decode the facade
            decoded = decode(vector["facade"])

            # Verify it matches the original
            assert decoded == vector["original"], (
                f"Decode mismatch for {vector['description']}"
            )

    def test_deterministic_encoding(self):
        """Test that encoding is deterministic across multiple runs"""
        test_cases = [
            {
                "k0": 0x123456789ABCDEF0,
                "k1": 0xFEDCBA9876543210,
                "uuid": "550e8400-e29b-71d4-a716-446655440000",
            },
            {
                "k0": 0x0000000000000000,
                "k1": 0x0000000000000000,
                "uuid": "01234567-89ab-7def-8123-456789abcdef",
            },
            {
                "k0": 0xFFFFFFFFFFFFFFFF,
                "k1": 0xFFFFFFFFFFFFFFFF,
                "uuid": "fedcba98-7654-7321-8098-765432109876",
            },
        ]

        for case in test_cases:
            set_keys(case["k0"], case["k1"])

            # Encode multiple times
            results = []
            for _ in range(10):
                facade = encode(case["uuid"])
                results.append(facade)

            # All results should be identical
            assert all(r == results[0] for r in results), (
                f"Non-deterministic encoding for keys {case['k0']:016x}, {case['k1']:016x}"
            )

    def test_key_independence(self):
        """Test that different keys produce different results"""
        test_uuid = "550e8400-e29b-71d4-a716-446655440000"

        key_pairs = [
            (0x1111111111111111, 0x2222222222222222),
            (0x3333333333333333, 0x4444444444444444),
            (0x5555555555555555, 0x6666666666666666),
            (0x7777777777777777, 0x8888888888888888),
        ]

        facades = []
        for k0, k1 in key_pairs:
            set_keys(k0, k1)
            facade = encode(test_uuid)
            facades.append(facade)

        # All facades should be different
        assert len(set(facades)) == len(facades), (
            "Different keys produced identical facades"
        )

        # But all should decode back to the original
        for i, (k0, k1) in enumerate(key_pairs):
            set_keys(k0, k1)
            decoded = decode(facades[i])
            assert decoded == test_uuid, f"Decode failed for key pair {i}"

    def test_random_bits_preservation(self):
        """Test that random bits are preserved correctly across encode/decode"""
        test_cases = [
            "550e8400-e29b-71d4-a716-446655440000",  # Original test case
            "01234567-89ab-7def-8123-456789abcdef",  # Sequential pattern
            "fedcba98-7654-7321-8098-765432109876",  # Reverse pattern
            "aaaaaaaa-bbbb-7ccc-8ddd-eeeeeeeeeeee",  # Repeated patterns
            "12345678-9abc-7def-8000-000000000001",  # Sparse pattern
        ]

        set_keys(0x123456789ABCDEF0, 0xFEDCBA9876543210)

        for test_uuid in test_cases:
            facade = encode(test_uuid)
            decoded = decode(facade)

            # Convert to bytes for bit-level comparison
            original_bytes = bytes.fromhex(test_uuid.replace("-", ""))
            decoded_bytes = bytes.fromhex(decoded.replace("-", ""))

            # Check that random bits are preserved
            # According to the C implementation, these bits should be identical:
            # - Low nibble of byte 6 (rand_a low 4 bits)
            # - Byte 7 (rand_a high 8 bits)
            # - Low 6 bits of byte 8 (rand_b low 6 bits)
            # - Bytes 9-15 (rand_b high 56 bits)

            assert (original_bytes[6] & 0x0F) == (decoded_bytes[6] & 0x0F), (
                f"Byte 6 low nibble mismatch for {test_uuid}"
            )
            assert original_bytes[7] == decoded_bytes[7], (
                f"Byte 7 mismatch for {test_uuid}"
            )
            assert (original_bytes[8] & 0x3F) == (decoded_bytes[8] & 0x3F), (
                f"Byte 8 low 6 bits mismatch for {test_uuid}"
            )
            assert original_bytes[9:] == decoded_bytes[9:], (
                f"Bytes 9-15 mismatch for {test_uuid}"
            )

    def test_version_and_variant_handling(self):
        """Test correct handling of version and variant bits"""
        test_uuid = "550e8400-e29b-71d4-a716-446655440000"  # Version 7
        set_keys(0x123456789ABCDEF0, 0xFEDCBA9876543210)

        facade = encode(test_uuid)
        decoded = decode(facade)

        # Convert to bytes for inspection
        original_bytes = bytes.fromhex(test_uuid.replace("-", ""))
        facade_bytes = bytes.fromhex(facade.replace("-", ""))
        decoded_bytes = bytes.fromhex(decoded.replace("-", ""))

        # Original should be version 7
        assert (original_bytes[6] >> 4) == 7, "Original should be version 7"

        # Facade should be version 4
        assert (facade_bytes[6] >> 4) == 4, "Facade should be version 4"

        # Decoded should be version 7 again
        assert (decoded_bytes[6] >> 4) == 7, "Decoded should be version 7"

        # Variant bits should be RFC 4122 (10xxxxxx) in both facade and decoded
        assert (facade_bytes[8] & 0xC0) == 0x80, "Facade should have RFC 4122 variant"
        assert (decoded_bytes[8] & 0xC0) == 0x80, "Decoded should have RFC 4122 variant"

    def test_edge_case_timestamps(self):
        """Test edge cases for timestamp values"""
        edge_cases = [
            "00000000-0000-7000-8000-000000000000",  # Minimum timestamp
            "ffffffff-ffff-7fff-8fff-ffffffffffff",  # Maximum timestamp (adjusted for version/variant)
            "80000000-0000-7000-8000-000000000000",  # Mid-range timestamp
        ]

        set_keys(0x123456789ABCDEF0, 0xFEDCBA9876543210)

        for test_uuid in edge_cases:
            facade = encode(test_uuid)
            decoded = decode(facade)

            assert decoded == test_uuid, f"Edge case failed for {test_uuid}"
            assert uuid_parse(facade) == 1, f"Invalid facade for edge case {test_uuid}"

    def test_cross_implementation_test_vectors(self):
        """
        Test with known good test vectors that should match Node.js implementation.

        These are hardcoded test vectors that represent the expected behavior
        and should be identical across implementations.
        """
        # These test vectors would ideally be generated by a reference implementation
        # or shared between the Python and Node.js versions

        known_vectors = [
            {
                "keys": {"k0": 0x0123456789ABCDEF, "k1": 0xFEDCBA9876543210},
                "input": "550e8400-e29b-71d4-a716-446655440000",
                # The expected output would be determined by running the Node.js version
                # For now, we'll compute it and verify consistency
            },
            {
                "keys": {"k0": 0x0000000000000000, "k1": 0x0000000000000000},
                "input": "01234567-89ab-7def-8123-456789abcdef",
                # With zero keys, the facade should be different but predictable
            },
        ]

        for vector in known_vectors:
            set_keys(vector["keys"]["k0"], vector["keys"]["k1"])

            # Encode and verify it's consistent
            facade1 = encode(vector["input"])
            facade2 = encode(vector["input"])

            assert facade1 == facade2, "Encoding should be deterministic"

            # Verify roundtrip
            decoded = decode(facade1)
            assert decoded == vector["input"], "Roundtrip should preserve original"

            # Store the result for cross-language verification
            print(
                f"Test vector: keys=({vector['keys']['k0']:016x}, {vector['keys']['k1']:016x}), input={vector['input']}, facade={facade1}"
            )

    def test_siphash_compatibility(self):
        """Test that the SipHash implementation produces expected results"""
        # This test verifies that our SipHash implementation matches the reference
        # We can't directly test SipHash since it's internal, but we can test
        # that the overall encoding is consistent

        # Use known keys and inputs that exercise different SipHash paths
        test_cases = [
            {
                "k0": 0x0706050403020100,
                "k1": 0x0F0E0D0C0B0A0908,
                "uuid": "550e8400-e29b-71d4-a716-446655440000",
            },
            {
                "k0": 0x1716151413121110,
                "k1": 0x1F1E1D1C1B1A1918,
                "uuid": "01234567-89ab-7def-8123-456789abcdef",
            },
        ]

        for case in test_cases:
            set_keys(case["k0"], case["k1"])

            # Encode multiple times to ensure consistency
            facades = [encode(case["uuid"]) for _ in range(5)]

            # All should be identical
            assert all(f == facades[0] for f in facades), (
                f"Inconsistent SipHash for case {case}"
            )

            # Verify roundtrip
            for facade in facades:
                decoded = decode(facade)
                assert decoded == case["uuid"], (
                    f"SipHash roundtrip failed for case {case}"
                )
